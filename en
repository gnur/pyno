#!/bin/bash

BASE_DIR=~/ll
# cd to the basedir so editors have the correct context
cd $BASE_DIR

# notes are stored in BASE_DIR/<year>/<month>/yyyy-mm-dd.md

# when `en` is called without arguments it opens a fuzzy menu with gum filter
#
# today: finds the last daily note, copies the todo items from that note (prefixed with '- [ ]') and adds a date to that todo if it doesn't have one already and sorts the TODO items reversed on date.
# 2020-02-02.md:
# ## todo
# - [ ] 2020-01-17: party time
# - [ ] finish en
# will become:
# 2020-02-03.md:
# # 2020-02-03
# ## todo
# - [ ] 2020-02-02: finish en
# - [ ] 2020-01-17: party time
#
#
# new: asks for the filename with gum and creates a new <filename>.md note and opens it with $EDITOR
# search: opens a ripgrep based fzf filter menu to search all notes for content and opens the selected note with $EDITOR
# find: opens a fd based gum filter menu to find a certain note and opens it with $EDITOR
# index: updates the index.md with references to all markdown files found in the BASE_DIR and opens index.md with $EDITOR

# Function to create a new note
new_note() {
    # Ask for the filename using gum
    filename=$(gum input --placeholder "Enter filename (without .md)")
    if [ -z "$filename" ]; then
        echo "No filename provided. Exiting."
        exit 1
    fi

    filepath="$BASE_DIR/$filename.md"

    # If the file doesn't exist, create it. Then open it.
    if [ ! -f "$filepath" ]; then
        touch "$filepath"
        echo "# ${filename}" > "$filepath"
    fi
    $EDITOR "$filepath"
}

index_notes() {
    local expanded_base_dir
    expanded_base_dir=$(eval echo "$BASE_DIR")
    local index_file="$expanded_base_dir/index.md"

    echo "# Index" > "$index_file"
    find "$expanded_base_dir" -name "*.md" -not -name "index.md" | sort | while read -r file; do
        # To create a relative path for the link, remove the BASE_DIR prefix
        local relative_path="${file#$expanded_base_dir/}"
        # Use the filename without the extension as the link text
        local link_text
        link_text=$(basename "$file" .md)
        echo "- [$link_text](./$relative_path)" >> "$index_file"
    done

    $EDITOR "$index_file"
}

find_note() {
    local expanded_base_dir
    expanded_base_dir=$(eval echo "$BASE_DIR")

    # Use fd to find all markdown files, strip the base path for display,
    # and let the user select one.
    selected_relative_path=$(fd . --extension md "$expanded_base_dir" | sed "s|^$expanded_base_dir/||" | gum filter)

    # If a file was selected, reconstruct the full path and open it.
    if [ -n "$selected_relative_path" ]; then
        selected_file="$expanded_base_dir/$selected_relative_path"
        $EDITOR "$selected_file"
    else
        echo "No file selected."
    fi
}

search_note() {
    local expanded_base_dir
    expanded_base_dir=$(eval echo "$BASE_DIR")

    # Use ripgrep to find all matches, strip the base path for display,
    # and pipe them to fzf for selection.
    local selection
    selection=$(rg --line-number --no-heading --smart-case "" "$expanded_base_dir" --glob '*.md' | sed "s|^$expanded_base_dir/||" | fzf)

    # If a selection is made, reconstruct the full path and open it.
    if [ -n "$selection" ]; then
        local relative_path
        relative_path=$(echo "$selection" | cut -d: -f1)
        local file_path="$expanded_base_dir/$relative_path"
        $EDITOR "$file_path"
    else
        echo "No match selected."
    fi
}

today_note() {
    local expanded_base_dir
    expanded_base_dir=$(eval echo "$BASE_DIR")
    local today_date
    today_date=$(date +%Y-%m-%d)
    local year
    year=$(date +%Y)
    local month
    month=$(date +%m)

    # Create the directory structure if it doesn't exist
    mkdir -p "$expanded_base_dir/$year/$month"

    local today_filepath="$expanded_base_dir/$year/$month/$today_date.md"

    # If today's note already exists, just open it
    if [ -f "$today_filepath" ]; then
        $EDITOR "$today_filepath"
        return
    fi

    # Find the last daily note (excluding today)
    local last_note
    last_note=$(find "$expanded_base_dir" -type f -name "*-*-*.md" | grep -E '/[0-9]{4}/[0-9]{2}/[0-9]{4}-[0-9]{2}-[0-9]{2}\.md$' | sort | grep -v "$today_date.md" | tail -n 1)

    # Create the new note with a header
    echo "# $today_date" > "$today_filepath"
    echo "" >> "$today_filepath"
    echo "## todo" >> "$today_filepath"

    if [ -n "$last_note" ]; then
        local last_note_date
        last_note_date=$(basename "$last_note" .md)

        # Process and sort todos from the last note
        local todos
        todos=$(grep -E '^\s*-\s*\[\s*\]' "$last_note" | while read -r todo; do
            # Check if the todo item already has a date prefix (allowing for indentation)
            if [[ "$todo" =~ .*[0-9]{4}-[0-9]{2}-[0-9]{2}:.* ]]; then
                echo "$todo"
            else
                # Add the date of the last note, preserving indentation
            		echo "${todo//\[ ]/[ ] $last_note_date:}"
            fi
        done | sort -r)

        if [ -n "$todos" ]; then
            echo "$todos" >> "$today_filepath"
        fi
    fi

    $EDITOR "$today_filepath"
}


# Main logic
if [ -z "$1" ]; then
    # No arguments, show fuzzy menu
    options="today\nnew\nsearch\nfind\nindex"
    selected_option=$(echo -e "$options" | gum filter)

    case $selected_option in
        "new")
            new_note
            ;;
        "search")
            search_note
            ;;
        "find")
            find_note
            ;;
        "index")
            index_notes
            ;;
        "today")
            today_note
            ;;
        *)
            echo "No option selected. Exiting."
            exit 1
            ;;
    esac
else
    # Handle subcommands passed as arguments
    case $1 in
        "new")
            new_note
            ;;
        "search")
            search_note
            ;;
        "find")
            find_note
            ;;
        "index")
            index_notes
            ;;
        "today")
            today_note
            ;;
        *)
            echo "Unknown command: $1"
            exit 1
            ;;
    esac
fi
